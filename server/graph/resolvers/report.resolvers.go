package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	graphql_models "server/graph/model"
	"server/middlewares"
	"server/persistence/models"
	"strings"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

// Report is the resolver for the report field.
func (r *queryResolver) Report(ctx context.Context, filter graphql_models.ReportFilter) (*graphql_models.Report, error) {
	ginContext, err := middlewares.GinContextFromContext(ctx)
	if err != nil {
		return nil, err
	}

	account, err := middlewares.ForContext(ginContext)
	if err != nil {
		return nil, err
	}

	user, err := r.UserService.Repo.GetUserByEmail(account.Account)
	if err != nil {
		return nil, err
	}

	var userExports []models.User
	var ids []primitive.ObjectID

	if filter.SpecifyTeacherIn {
		ids = make([]primitive.ObjectID, len(filter.TeachersIn)+1)
		ids[0] = user.ID
		for i, id := range filter.TeachersIn {
			objectId, err := primitive.ObjectIDFromHex(*id)
			if err != nil {
				return nil, err
			}
			ids[i+1] = objectId
		}

		userExports, err = r.UserService.Repo.GetUsersByIds(ids)
		if err != nil {
			return nil, err
		}
	} else {
		userExports, err = r.UserService.Repo.GetAllUsers()
		if err != nil {
			return nil, err
		}
		ids = make([]primitive.ObjectID, len(userExports))
		for i, userExport := range userExports {
			ids[i] = userExport.ID
		}
	}

	userExportsMap := make(map[primitive.ObjectID]string)
	userNames := make([]*string, 0)

	for _, userExport := range userExports {
		userExportsMap[userExport.ID] = userExport.Username
		userNames = append(userNames, &userExport.Username)
	}

	report := &graphql_models.Report{
		Teachers:  userNames,
		StartDate: filter.StartDate,
		EndDate:   filter.EndDate,
	}

	if filter.ClassSchedule {

		courses, err := r.ClassScheduleService.Repo.GetCourseReports(ids, filter.StartDate, filter.EndDate)
		if err != nil {
			return nil, err
		}

		classScheduleReport := make([]*string, len(courses))
		for i, course := range courses {
			tempString := fmt.Sprintf("%s ( %s , %s )", course.Name, course.StartDate.Time().Format("2006-01-02"), course.TeacherNames)
			classScheduleReport[i] = &tempString
		}

		report.ClassScheduleReport = classScheduleReport
	}

	if filter.CompGuidance {

		compGuidances, err := r.CompGuidanceService.Repo.GetCompGuidanceReports(ids, filter.StartDate, filter.EndDate)
		if err != nil {
			return nil, err
		}

		compGuidanceReport := make([]*string, len(compGuidances))
		for i, compGuidance := range compGuidances {
			tempString := fmt.Sprintf("%s ( %s , %s )", compGuidance.ProjectName, compGuidance.GuidanceDate.Time().Format("2006-01-02"), userExportsMap[compGuidance.UserId])
			compGuidanceReport[i] = &tempString
		}

		report.CompGuidanceReport = compGuidanceReport
	}

	if filter.EduReform {

		eduReforms, err := r.EduReformService.Repo.GetEduReformReports(ids, filter.StartDate, filter.EndDate)
		if err != nil {
			return nil, err
		}

		eduReformReport := make([]*string, len(eduReforms))
		for i, eduReform := range eduReforms {
			tempString := fmt.Sprintf("%s ( %s , %s )", eduReform.Title, eduReform.StartDate.Time().Format("2006-01-02"), ConvertIdsToString(eduReform.TeachersIn, userExportsMap))
			eduReformReport[i] = &tempString
		}

		report.EduReformReport = eduReformReport
	}

	if filter.Mentorship {

		mentorships, err := r.MentorshipService.Repo.GetMentorshipReports(ids, filter.StartDate, filter.EndDate)
		if err != nil {
			return nil, err
		}

		mentorshipReport := make([]*string, len(mentorships))
		for i, mentorship := range mentorships {
			tempString := fmt.Sprintf("%s ( %s , %s )", mentorship.ProjectName, mentorship.GuidanceDate.Time().Format("2006-01-02"), userExportsMap[mentorship.UserId])
			mentorshipReport[i] = &tempString
		}

		report.MentorshipReport = mentorshipReport
	}

	if filter.Monograph {

		monographs, err := r.MonographService.Repo.GetMonographReports(ids, filter.StartDate, filter.EndDate)
		if err != nil {
			return nil, err
		}

		monographReport := make([]*string, len(monographs))
		for i, monograph := range monographs {
			tempString := fmt.Sprintf("%s ( %s , %s )", monograph.Title, monograph.PublishDate.Time().Format("2006-01-02"), ConvertIdsToString(monograph.TeachersIn, userExportsMap))
			monographReport[i] = &tempString
		}

		report.MonographReport = monographReport

	}

	if filter.Paper {

		papers, err := r.PaperService.Repo.GetPaperReports(ids, filter.StartDate, filter.EndDate)
		if err != nil {
			return nil, err
		}

		paperReport := make([]*string, len(papers))
		for i, paper := range papers {
			tempString := fmt.Sprintf("%s ( %s , %s )", paper.Title, paper.PublishDate.Time().Format("2006-01-02"), ConvertIdsToString(paper.TeachersIn, userExportsMap))
			paperReport[i] = &tempString
		}

		report.PaperReport = paperReport

	}

	if filter.SciResearch {

		sciResearches, err := r.SciResearchService.Repo.GetSciResearchReports(ids, filter.StartDate, filter.EndDate)
		if err != nil {
			return nil, err
		}

		sciResearchReport := make([]*string, len(sciResearches))
		for i, sciResearch := range sciResearches {
			tempString := fmt.Sprintf("%s ( %s , %s )", sciResearch.Title, sciResearch.StartDate.Time().Format("2006-01-02"), ConvertIdsToString(sciResearch.TeachersIn, userExportsMap))
			sciResearchReport[i] = &tempString
		}

		report.SciResearchReport = sciResearchReport

	}

	if filter.UGPGGuidance {

		ugpgGuidances, err := r.UGPGGuidanceService.Repo.GetUGPGGuidanceReports(ids, filter.StartDate, filter.EndDate)
		if err != nil {
			return nil, err
		}

		ugpgGuidanceReport := make([]*string, len(ugpgGuidances))
		for i, ugpgGuidance := range ugpgGuidances {
			tempString := fmt.Sprintf("%s ( %s , %s )", ugpgGuidance.ThesisTopic, ugpgGuidance.DefenseDate.Time().Format("2006-01-02"), userExportsMap[ugpgGuidance.UserId])
			ugpgGuidanceReport[i] = &tempString
		}

		report.UGPGGuidanceReport = ugpgGuidanceReport

	}

	return report, nil
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func ConvertIdsToString(ids []primitive.ObjectID, userExportsMap map[primitive.ObjectID]string) string {
	idsString := make([]string, 0)
	for _, id := range ids {
		if userExportsMap[id] != "" {
			idsString = append(idsString, userExportsMap[id])
		}
	}
	return strings.Join(idsString, ",")
}

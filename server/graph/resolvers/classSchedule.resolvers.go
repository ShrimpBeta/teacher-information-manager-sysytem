package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	graphql_models "server/graph/model"
	"server/middlewares"

	"github.com/99designs/gqlgen/graphql"
)

// CreateCourse is the resolver for the createCourse field.
func (r *mutationResolver) CreateCourse(ctx context.Context, termID string, courseData graphql_models.CourseData) (*graphql_models.Course, error) {
	ginContext, err := middlewares.GinContextFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// if no token found, return an error
	account, err := middlewares.ForContext(ginContext)
	if err != nil {
		return nil, err
	}

	user, err := r.UserService.Repo.GetUserByEmail(account.Account)
	if err != nil {
		return nil, err
	}

	return r.ClassScheduleService.CreateCourese(user.ID, termID, courseData)
}

// UpdateCourse is the resolver for the updateCourse field.
func (r *mutationResolver) UpdateCourse(ctx context.Context, termID string, courseID string, courseData graphql_models.CourseData) (*graphql_models.Course, error) {
	ginContext, err := middlewares.GinContextFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// if no token found, return an error
	account, err := middlewares.ForContext(ginContext)
	if err != nil {
		return nil, err
	}

	user, err := r.UserService.Repo.GetUserByEmail(account.Account)
	if err != nil {
		return nil, err
	}

	return r.ClassScheduleService.UpdateCourse(user.ID, termID, courseID, courseData)
}

// DeleteCourse is the resolver for the deleteCourse field.
func (r *mutationResolver) DeleteCourse(ctx context.Context, termID string, courseID string) (*graphql_models.Course, error) {
	ginContext, err := middlewares.GinContextFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// if no token found, return an error
	account, err := middlewares.ForContext(ginContext)
	if err != nil {
		return nil, err
	}

	user, err := r.UserService.Repo.GetUserByEmail(account.Account)
	if err != nil {
		return nil, err
	}

	return r.ClassScheduleService.DeleteCourse(user.ID, termID, courseID)
}

// CreateacademicTerm is the resolver for the createacademicTerm field.
func (r *mutationResolver) CreateAcademicTerm(ctx context.Context, termData graphql_models.NewAcademicTerm) (*graphql_models.AcademicTerm, error) {
	ginContext, err := middlewares.GinContextFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// if no token found, return an error
	account, err := middlewares.ForContext(ginContext)
	if err != nil {
		return nil, err
	}

	user, err := r.UserService.Repo.GetUserByEmail(account.Account)
	if err != nil {
		return nil, err
	}

	return r.ClassScheduleService.CreateAcademicTerm(user.ID, termData)
}

// UpdateacademicTerm is the resolver for the updateacademicTerm field.
func (r *mutationResolver) UpdateAcademicTerm(ctx context.Context, termID string, termData graphql_models.UpdateAcademicTerm) (*graphql_models.AcademicTerm, error) {
	ginContext, err := middlewares.GinContextFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// if no token found, return an error
	account, err := middlewares.ForContext(ginContext)
	if err != nil {
		return nil, err
	}

	user, err := r.UserService.Repo.GetUserByEmail(account.Account)
	if err != nil {
		return nil, err
	}

	return r.ClassScheduleService.UpdateAcademicTerm(user.ID, termID, termData)
}

// DeleteacademicTerm is the resolver for the deleteacademicTerm field.
func (r *mutationResolver) DeleteAcademicTerm(ctx context.Context, termID string) (*graphql_models.AcademicTerm, error) {
	ginContext, err := middlewares.GinContextFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// if no token found, return an error
	account, err := middlewares.ForContext(ginContext)
	if err != nil {
		return nil, err
	}

	user, err := r.UserService.Repo.GetUserByEmail(account.Account)
	if err != nil {
		return nil, err
	}

	return r.ClassScheduleService.DeleteAcademicTerm(user.ID, termID)
}

// UploadAcademicTerm is the resolver for the uploadAcademicTerm field.
func (r *mutationResolver) UploadAcademicTerm(ctx context.Context, file graphql.Upload) (*graphql_models.AcademicTermPreview, error) {
	ginContext, err := middlewares.GinContextFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// if no token found, return an error
	_, err = middlewares.ForContext(ginContext)
	if err != nil {
		return nil, err
	}

	panic(fmt.Errorf("not implemented: UploadAcademicTerm - uploadAcademicTerm"))
}

// AcademicTerm is the resolver for the academicTerm field.
func (r *queryResolver) AcademicTerm(ctx context.Context, id string) (*graphql_models.AcademicTerm, error) {
	ginContext, err := middlewares.GinContextFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// if no token found, return an error
	account, err := middlewares.ForContext(ginContext)
	if err != nil {
		return nil, err
	}

	user, err := r.UserService.Repo.GetUserByEmail(account.Account)
	if err != nil {
		return nil, err
	}

	return r.ClassScheduleService.GetAcademicTermById(user.ID, id)
}

// AcademicTermsByFilter is the resolver for the academicTermsByFilter field.
func (r *queryResolver) AcademicTermsByFilter(ctx context.Context, filter graphql_models.AcademicTermFilter, offset int, limit int) (*graphql_models.AcademicTermQuery, error) {
	ginContext, err := middlewares.GinContextFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// if no token found, return an error
	account, err := middlewares.ForContext(ginContext)
	if err != nil {
		return nil, err
	}

	user, err := r.UserService.Repo.GetUserByEmail(account.Account)
	if err != nil {
		return nil, err
	}

	return r.ClassScheduleService.GetAcademicTermsByFilter(user.ID, filter, offset, limit)
}

// AcademicTermsID is the resolver for the AcademicTermsID field.
func (r *queryResolver) AcademicTermsID(ctx context.Context, id []string) ([]*graphql_models.AcademicTerm, error) {
	ginContext, err := middlewares.GinContextFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// if no token found, return an error
	account, err := middlewares.ForContext(ginContext)
	if err != nil {
		return nil, err
	}

	user, err := r.UserService.Repo.GetUserByEmail(account.Account)
	if err != nil {
		return nil, err
	}

	return r.ClassScheduleService.GetAcademicTermsByIds(user.ID, id)
}
